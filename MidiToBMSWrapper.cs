using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using JaiMaker.Assembler;
using MidiSharp;

using Be.IO;

namespace JaiMaker
{
    class MidiToBMSAssembler
    {
        public ISequenceAssembler Assembler;
        public MidiSequence MidiSeq;
        public Dictionary<int, JAIMakerSoundInfo> MIDIInstrumentRemap;
        private enum MessageLevel
        {
            ERROR,
            WARNING,
            INFO,
        }

        public BeBinaryWriter output;
        

        public MidiToBMSAssembler(MidiSequence MIDI, ISequenceAssembler ASS)
        {
            MidiSeq = MIDI;
            Assembler = ASS;
        }

        #region Address Storage / Call+Jump management
        private Dictionary<string, int> addressLookup = new Dictionary<string, int>();
        private long MasterLoopDelta = -1;
        private long MasterLoopDeltaEnd = -1;
        private void flushAddressTable()
        {
            addressLookup = new Dictionary<string, int>();
        }
        private void saveAddress(string name)
        {
            addressLookup[name] = (int)Assembler.output.BaseStream.Position;
        }
        private int getAddress(string name)
        {
            int outaddr;
            if (!addressLookup.TryGetValue(name, out outaddr))
                return -1;
            return outaddr;
        }

        private void message(string message, MessageLevel level = MessageLevel.INFO)
        {
            var cc = Console.ForegroundColor;
            Console.ForegroundColor = ConsoleColor.Magenta;
            Console.Write("midi2bms - ");
            if (level == MessageLevel.ERROR)
                Console.ForegroundColor = ConsoleColor.DarkRed;
            else if (level==MessageLevel.WARNING)
                Console.ForegroundColor = ConsoleColor.DarkYellow;
            else
                Console.ForegroundColor = cc;
            Console.WriteLine(message);
            Console.ForegroundColor = cc;

        }

        private void goAddress(string name, short offset = 0)
        {
            var addr = getAddress(name);
            if (addr != -1)
                Assembler.output.BaseStream.Position = addr + offset;
            else
                throw new Exception($"Return position miss {name}");
        }

        private void freeAddress(string name)
        {
            addressLookup.Remove(name);
        }
        #endregion

        #region  Remapping Functions
  
        private int calculateEndingDelta(MidiSequence midSeq)
        {
            var largest_delta = 0;
            for (int tridx = 0; tridx < midSeq.Tracks.Count; tridx++)
            {
                var total_trk_delta = 0; 
                var CTrk = midSeq.Tracks[tridx];
                for (int evntid = 0; evntid < CTrk.Events.Count; evntid++) 
                {
                    var CEvent = CTrk.Events[evntid]; 
                    total_trk_delta += (int)CEvent.DeltaTime;
                }
                if (total_trk_delta > largest_delta)  
                    largest_delta = total_trk_delta; 
            }
            return largest_delta;
        }


        private int[] voiceLookup;
        private int allocateVoice(int note)
        {
            for (int i = 0; i < 7; i++)
                if (voiceLookup[i] == 0)
                {
                    voiceLookup[i] = note;
                    return i;
                }
            return -1;
        }

        private int isVoiceAllocated(int note)
        {
            for (int i = 0; i < 7; i++)
                if (voiceLookup[i] == note)                
                    return i;

            return -1;
        }

        private int freeVoice(int note)
        {
            for (int i = 0; i < 7; i++)
                if (voiceLookup[i] == note)
                {
                    voiceLookup[i] = 0;
                    return i;
                }
            return -1;
        }

   


        public void processSequence()
        {
            var endDelta = calculateEndingDelta(MidiSeq);
            message("====================================================");
            if (Assembler != null)
                message($"JV Assembler ready! {Assembler.ToString()}");
            //Assembler.writePrint("Sequence generated by JaiMaker-2!");
            Assembler.writeTempoChange((short)MidiSeq.TicksPerBeatOrFrame);
            message($"Assembler ticks per frame {(short)MidiSeq.TicksPerBeatOrFrame}");
            Assembler.writeTimebaseChange((short)120);

            for (int trk = 0; trk < MidiSeq.Tracks.Count; trk++)
            {
                if (trk == 0)
                    continue;
                saveAddress($"trk{trk - 1}Open");
                Assembler.writeOpenTrack((byte)trk, 0);
            }
        
            // These tracks are all -1 because we want to write the control / tempo track + the melodic tracks, but we don't need to write an opener for the tempo track.
            for (int trk = 0; trk < MidiSeq.Tracks.Count; trk++) // 
            {
                voiceLookup = new int[7];
                if (trk != 0) // root track doesn't need opening.
                {
                    saveAddress("last"); // Save previous address (where we're opening from)
                    goAddress($"trk{trk-1}Open"); // Go back to header and write the address where that track starts
                    Assembler.writeOpenTrack((byte)(trk -1), getAddress($"last"));
                    freeAddress($"trk{trk-1}Open");
                    goAddress("last"); // Reuturn
                }
                writeTrack(MidiSeq.Tracks[trk], (byte)(trk), endDelta);
                message($"Finished assembling TRK{trk:X2}");
            }

            Assembler.writeFinish();
            util.padTo(output, 32);

            if (MidiSeq.Tracks.Count > 17) {
                message("!!!! WARNING !!!! The assembler generated more tracks than expected (C1 XX > 0xF)! This will crash if you try to play it on hardware.", MessageLevel.ERROR);
            }
        }

        public void writeTrack(MidiTrack mTrack, byte trackID, int lastDelta)
        {
            int currentInst = 0;
            int currentBnk = 0;
            long totalDelta = 0;
            bool wroteLoop = false;
            int waitParameterNumber = -1;
            freeAddress("MASTER_LOOP");
            freeAddress("LOOP");

            int rpn = 4; // Pitchwheel range. 
            if (trackID != 0)
            {
                Assembler.writeBankChange((byte)Root.instrumentBanks[trackID - 1]); // 0xa4 0x20 0xYY
                Assembler.writeProgramChange((byte)Root.programs[trackID - 1]); // 0xA4 0x21 0xYY ??
            }


            for (int i = 0; i < mTrack.Events.Count; i++)
            {
                var currentEvent = mTrack.Events[i];
                var prevDelta = totalDelta;
                totalDelta += currentEvent.DeltaTime;

                if (MasterLoopDelta >= 0 & totalDelta >= MasterLoopDelta & wroteLoop == false)
                {
                    var offsetIntoDelta = MasterLoopDelta - prevDelta; // What did the last one not fulfil. 
                    var transitionDelta = totalDelta - prevDelta; // Time between current and last event
                    var frontDelta = transitionDelta - offsetIntoDelta;  //  Take what we're filling in and slice it off of the real delay

                    // Split the delta down the middle, and save the address between it. 
                    message($"Split delta for track {trackID} for loop event at {prevDelta + offsetIntoDelta} -- BEFORE {offsetIntoDelta} AFTER {frontDelta}");
                    if (offsetIntoDelta > 0)
                        Assembler.writeWait((int)offsetIntoDelta);

                    saveAddress("MASTER_LOOP");
       

                    if ((frontDelta + offsetIntoDelta) >= MasterLoopDeltaEnd & MasterLoopDeltaEnd > 0)
                    {
                        var osd = MasterLoopDeltaEnd - offsetIntoDelta;
                        Assembler.writeWait((int)osd);
                        Assembler.writeJump(getAddress("MASTER_LOOP"));
                        Assembler.writeFinish();
                        message($"Track front delta exceeds loop end length for {trackID}. Correcting.",MessageLevel.WARNING);
                        return;

                    }
                    wroteLoop = true;
                    if (frontDelta > 0)
                        Assembler.writeWait((int)frontDelta);

                } else if (MasterLoopDeltaEnd > 0 & totalDelta >=MasterLoopDeltaEnd & wroteLoop==true)
                {
                    var offsetIntoDelta = MasterLoopDeltaEnd - prevDelta; 
                    var transitionDelta = totalDelta - prevDelta;
                    // We don't need FrontDelta, because we're terminating the track. 
                    if (offsetIntoDelta > 0)
                        Assembler.writeWait((int)offsetIntoDelta);
                    if (getAddress("MASTER_LOOP") > 0)
                        Assembler.writeJump(getAddress("MASTER_LOOP"));
                    Assembler.writeFinish();
                    message($"Early subtrack termination ({trackID}) for master loop at delta {offsetIntoDelta + prevDelta}. ");

                    return;
                }
                else if (currentEvent.DeltaTime > 0)
                    Assembler.writeWait((int)currentEvent.DeltaTime);

                if (currentEvent is MidiSharp.Events.Voice.Note.OnNoteVoiceMidiEvent)
                {
                    var ev = (MidiSharp.Events.Voice.Note.OnNoteVoiceMidiEvent)currentEvent;

                    var alloc = isVoiceAllocated(ev.Note);
                    if (alloc > -1)
                    {
                        Assembler.writeNoteOff((byte)alloc);
                        freeVoice(ev.Note);
                    }

                    if (ev.Velocity > 0)
                    {
                        var voice = allocateVoice(ev.Note);
                        if (voice > -1)
                            Assembler.writeNoteOn(ev.Note, ev.Velocity, (byte)voice);
                        else
                            message($"! Voice overflow on track {trackID}", MessageLevel.ERROR);
                    }
                }
                else if (currentEvent is MidiSharp.Events.Voice.Note.OffNoteVoiceMidiEvent)
                {
                    var ev = (MidiSharp.Events.Voice.Note.OffNoteVoiceMidiEvent)currentEvent;
                    //ev.Note = (byte)getNoteRemap(currentBnk, currentInst, ev.Note);
                    var voiceFree = freeVoice(ev.Note);
                    if (voiceFree > -1)
                        Assembler.writeNoteOff((byte)voiceFree);
                    else
                        message($"! NOTE_OFF({ev.Note}) did not exist in voice lookup (VID={voiceFree})! Voices may leak!", MessageLevel.ERROR);
                }
                else if (currentEvent is MidiSharp.Events.Meta.TempoMetaMidiEvent)
                {
                    var ev = (MidiSharp.Events.Meta.TempoMetaMidiEvent)currentEvent;
                    Assembler.writeTimebaseChange((short)(60000000 / ev.Value));
                }
                else if (currentEvent is MidiSharp.Events.Voice.ProgramChangeVoiceMidiEvent)
                {
                    var ev = (MidiSharp.Events.Voice.ProgramChangeVoiceMidiEvent)currentEvent;
                    /*
                 
                    if (Project.UseMidiOverride || !Project.UseMidiRemap)
                        continue;
                    var ovr = getMidiProgRemap(ev.Number);
                    if (!ovr.enable)
                        continue;
                    Assembler.writeBankChange((byte)ovr.bank); // 0xa4 0x20 0xYY
                    Assembler.writeProgramChange((byte)ovr.program); // 0xA4 0x21 0xYY ??
                    currentInst = ovr.program;
                    currentBnk = ovr.bank;
                    */

                    if (MIDIInstrumentRemap != null && MIDIInstrumentRemap.ContainsKey(ev.Number))
                    {
                        var remap = MIDIInstrumentRemap[ev.Number];
                        Assembler.writeBankChange((byte)remap.bank); // 0xa4 0x20 0xYY
                        Assembler.writeProgramChange((byte)remap.prog); // 0xA4 0x21 0xYY ??
                    }
                }
                else if (currentEvent is MidiSharp.Events.Voice.PitchWheelVoiceMidiEvent)
                {
                    var ev = (MidiSharp.Events.Voice.PitchWheelVoiceMidiEvent)currentEvent;
                    var RealValue = 128 * ev.LowerBits + ev.UpperBits; // MidiSharp calculates this wrong, in MIDI it's big endian.
                    Assembler.writePitchBend((short)((RealValue - 8192)));
                }
                else if (currentEvent is MidiSharp.Events.Voice.ControllerVoiceMidiEvent)
                {
                    var ev = (MidiSharp.Events.Voice.ControllerVoiceMidiEvent)currentEvent;
                    if (ev.Number == (byte)Controller.VolumeCourse)
                        Assembler.writeVolume(ev.Value);
                    else if (ev.Number == (byte)Controller.VolumeFine)
                        Assembler.writeVolume(ev.Value);
                    else if (ev.Number == (byte)Controller.PanPositionCourse)
                        Assembler.writePanning(ev.Value);
                    else if (ev.Number == (byte)Controller.PanPositionFine)
                        Assembler.writePanning(ev.Value);
                    else if (ev.Number == (byte)Controller.RegisteredParameterCourse)
                        waitParameterNumber = ev.Value;
                    else if (ev.Number == (byte)Controller.DataEntryCourse || ev.Number == (byte)Controller.DataEntryFine)
                        if (waitParameterNumber > -1) { 
                            message($"rpn prm 0x{waitParameterNumber:X4} -> {ev.Value}",MessageLevel.INFO);
                            if (waitParameterNumber==0) // RPN 0x0000 PITCH WHEEL RANGE
                                Assembler.writePitchSensitivity(ev.Value);
                            waitParameterNumber = -1;
                        }
                } else if (currentEvent is MidiSharp.Events.SystemExclusiveMidiEvent)
                {
                    var ev = (MidiSharp.Events.SystemExclusiveMidiEvent)currentEvent;

                   // Assembler.writePitchSensitivity(;
                   for (int ix=0; ix < ev.Data.Length; ix++)
                        Console.Write($"{ev.Data[ix]:X}-");
                    
                    Console.WriteLine();
                }
                else if (
                    currentEvent is MidiSharp.Events.Meta.Text.CuePointTextMetaMidiEvent ||
                    currentEvent is MidiSharp.Events.Meta.Text.LyricTextMetaMidiEvent ||
                    currentEvent is MidiSharp.Events.Meta.Text.MarkerTextMetaMidiEvent    
         
                 )
                {
                    var ev = (MidiSharp.Events.Meta.Text.BaseTextMetaMidiEvent)currentEvent;
                    if (ev.Text == "JLOOP" || ev.Text == "LOOP")
                        saveAddress("LOOP");

                    if (ev.Text == "MASTER_LOOP" || ev.Text == "MLOOP" || ev.Text == "loopStart")
                    {
                        MasterLoopDelta = totalDelta;
                        message($"Trapped loop_start event -- delta offset {totalDelta}");
                    }
                    

                    if (ev.Text == "MASTER_LOOP_END" || ev.Text == "MLOOPEND" || ev.Text=="loopEnd")
                        if (getAddress("MASTER_LOOP") > 0)
                        {
                            MasterLoopDeltaEnd = totalDelta;
                            message("Trapped early MASTER_LOOP_END -- terminating track compilation here to save space.");
                            Assembler.writeJump((int)getAddress("MASTER_LOOP"));
                            Assembler.writeFinish();
                            return;
                        }
                }
            }

            
            if (MasterLoopDelta > 0 & wroteLoop==false & MasterLoopDeltaEnd < 0) // Can only happen if the track has less data than the loop delta.
            {
                var offsetDelta = (int)MasterLoopDelta - (int)totalDelta; // Why long?
                Assembler.writeWait(offsetDelta);
                message($"Trapped early-end offset for track {trackID} for master loop at {offsetDelta + totalDelta} (not enough delta??)", MessageLevel.WARNING);
                saveAddress("MASTER_LOOP");
                totalDelta -= offsetDelta;  // If we don't do this, the line directly below responsible for synchronizing the ending will make the track wait too long to end.
            }

            if (MasterLoopDeltaEnd > totalDelta)
            {
                Assembler.writeWait((int)MasterLoopDeltaEnd - (int)totalDelta);
                Assembler.writeJump(getAddress("MASTER_LOOP"));
                Assembler.writeFinish();
                message($"[!] Not enough delta in track {trackID} for loop! Aligning....", MessageLevel.WARNING);
                return;
            }

            Assembler.writeWait((int)(lastDelta - totalDelta)); // Synchronize the ending of all tracks

            Assembler.writeFinish(); // close track.

            if (getAddress("LOOP") > 0)
                Assembler.writeJump((int)getAddress("LOOP"));

            if (getAddress("MASTER_LOOP") > 0)
                Assembler.writeJump((int)getAddress("MASTER_LOOP"));

            if (trackID==0)
                Assembler.writePrint("Assembled by JAIMaker");
        }

        #endregion
    }
}















